/*** 'Editable' - you can edit the code below based on the needs ***/
import java.util.concurrent.Callable;
import android.util.Log;

print("Very first line of logic after the import lines");

User user; // don't touch
String userid;

makeLocalID(){
    fetchOne("CREATE TABLE IF NOT EXISTS localSettings (key text primary key, value text);");
    fetchOne("drop view latestNonDeletedArchEntFormattedIdentifiers;");
    fetchOne("CREATE VIEW latestNonDeletedArchEntFormattedIdentifiers as " +
              "select uuid, aenttypeid, aenttypename, group_concat(response, '') as response, null as deleted " +
              "from ( " +
                "select uuid, aenttypeid, aenttypename, group_concat(format(formatstring, vocabname, measure, freetext, certainty), appendcharacterstring) as response, null as deleted, aentcountorder " +
                "from ( " +
                  "select uuid, aenttypeid, aenttypename, formatstring, vocabname, measure, freetext, certainty, appendcharacterstring, null as deleted, aentcountorder, vocabcountorder, attributeid " +
                  "from latestNonDeletedArchent " +
                    "JOIN aenttype using (aenttypeid) " +
                    "JOIN (select * from idealaent where isIdentifier='true') using (aenttypeid) " +
                    "join attributekey  using (attributeid) " +
                    "join latestNonDeletedAentValue using (uuid, attributeid) " +
                    "left outer join vocabulary using (attributeid, vocabid) " +
                  "order by uuid, aentcountorder, vocabcountorder " +
                ") " +
                "group by uuid, attributeid " +
                "having response is not null " +
                "order by uuid, aentcountorder) " +
              "group by uuid " +
              "order by uuid;"
    );


}
makeLocalID();

/*** Uneditable - you can edit the code below with extreme precaution ***/
/*** USER ***/

loadUsers() {
    fetchAll("select userid, fname || ' ' || lname from user where userdeleted is null;", new FetchCallback() {
        onFetch(result) {
            populateList("user/usertab/users", result);
        }
    });
}

String username = "";
String device = "";

login() {
    fetchOne("select userid,fname,lname,email from user where userid='" + getListItemValue() + "';", new FetchCallback() {
        onFetch(result) {
            user = new User(result.get(0),result.get(1),result.get(2),result.get(3));
            setUser(user);
            username = result.get(1) + " " + result.get(2);
            showTabGroup("oldBone");
        }
    });
}

loadUsers();

onEvent("user/usertab/users", "click", "login()");

/*** SYNC ***/

startSync() {
    setSyncEnabled(true);
    setFileSyncEnabled(true);
}

stopSync() {
    setSyncEnabled(false);
    setFileSyncEnabled(false);
}

/** Vocab Population **/
/* Populates the path specified vocabulary from the database based on the given attribute name, where type 
is the type of the vocab to populate (checkbox, dropdown, radio or list). */
makeVocab(String type, String path, String attrib, List vocabExclusions){
  fetchAll("select vocabid, vocabname from vocabulary join attributekey using (attributeid) where attributename = '" + attrib + "' order by vocabcountorder;",
    new FetchCallback() {
      onFetch(result) {
        print("makeVocab() result: " + result);
        if (result!=null && result.size()>0 && vocabExclusions!=null && vocabExclusions.size()>0) {
          List filteredVocab = new ArrayList();
          for(item : result) {
            if (vocabExclusions.contains(item.get(1))) {
              Log.d("makeVocab()", "removing vocab exclusion: " + item.get(1));
            } else {
              filteredVocab.add(item);
            }
          }
          result=filteredVocab;
        }
        print("makeVocab() filtered result: " + result);
        if(type.equals("CheckBoxGroup")) {
          populateCheckBoxGroup(path, result);
        } else if(type.equals("DropDown")) {
          populateDropDown(path, result);
        } else if(type.equals("RadioGroup")) {
          populateRadioGroup(path, result);
        } else if(type.equals("List")) {
          populateList(path, result);
        }
      }
    });
}

/** Wrapper for to make a vocab without an exlusion list **/
makeVocab(String type, String path, String attrib) {
  makeVocab(type, path, attrib, null);
}

/** Makes a dynamic vocab and populates it using a data_schema vocab, with a callbackFunction to execute after creating the dynamic view. **/
makeDynamicVocab(String type, String path, String attrib, String label, String callbackFunction) {
  viewDef = createViewDef();
  if (type.equals("CheckBoxGroup")) {
    viewDef.createCheckboxGroup();
  } else {
    return;
  }
  
  if (!isNull(label)) {
    viewDef.setLabel(label);
  }

  fetchAll("select vocabid, vocabname from vocabulary join attributekey using (attributeid) where attributename = '" + attrib + "' order by vocabcountorder;", new FetchCallback() {
    onFetch(result) {
      print ("Dynamic Vocab: " + result);
      for (item : result) {
        viewDef.addChoice(item.get(1), item.get(0));
      }
      createView(path, viewDef);
      if (callbackFunction != null && !isNull(callbackFunction)) {
        execute(callbackFunction);
      }
    }
  });
}

/** Makes a dynamic vocab and populates it using a data_schema vocab. **/
makeDynamicVocab(String type, String path, String attrib, String label) {
  makeDynamicVocab(type, path, attrib, label, null);
}


/**************************/
/** Editable Module Code **/
/**************************/

/** Populates the checkboxes, lists, ... for the Old Bone tabgroup using the vocabularies. **/
populateOldBoneAttributes() {
  makeVocab("RadioGroup", "oldBone/basicIdentification/cluster", "Cluster");
  makeVocab("RadioGroup", "oldBone/basicIdentification/clusterType", "Cluster Type");
  makeVocab("CheckBoxGroup", "oldBone/insituAndSurfaceBone/bodyPartsIdentified", "Body Parts Identifed");
  makeVocab("CheckBoxGroup", "oldBone/insituAndSurfaceBone/taxonIdentified", "Taxon Identified");
  makeVocab("CheckBoxGroup", "oldBone/insituAndSurfaceBone/bonePreservation", "Bone Preservation");
  makeVocab("CheckBoxGroup", "oldBone/insituAndSurfaceBone/deliberateSurfaceModification", "Deliberate Surface Modification");
  makeVocab("CheckBoxGroup", "oldBone/associatedMaterials/associatedInsituMaterial", "Associated in situ material");
  makeVocab("CheckBoxGroup", "oldBone/associatedMaterials/associatedSurfaceMaterial", "Associated surface material");

  // List insutuAssocMaterials = new ArrayList();
  // insutuAssocMaterials.add(new NameValuePair("{mussel}", "mussel"));
  // insutuAssocMaterials.add(new NameValuePair("{hs}", "hs"));
  // insutuAssocMaterials.add(new NameValuePair("{eggshell}", "eggshell"));
  // insutuAssocMaterials.add(new NameValuePair("{artefacts}", "artefacts"));
  // insutuAssocMaterials.add(new NameValuePair("{otherwork}", "otherwork"));
  // populateCheckBoxGroup("oldBone/associatedMaterials/associatedInsituMaterial", insutuAssocMaterials);
  // List surfaceAssocMaterials = new ArrayList();
  // surfaceAssocMaterials.add(new NameValuePair("{mussel}", "mussel"));
  // surfaceAssocMaterials.add(new NameValuePair("{hs}", "hs"));
  // surfaceAssocMaterials.add(new NameValuePair("{eggshell}", "eggshell"));
  // surfaceAssocMaterials.add(new NameValuePair("{artefacts}", "artefacts"));
  // surfaceAssocMaterials.add(new NameValuePair("{otherwork}", "otherwork"));
  // populateCheckBoxGroup("oldBone/associatedMaterials/associatedSurfaceMaterial", surfaceAssocMaterials);


  fetchAll("select vocabid, vocabname, pictureurl from vocabulary left join attributekey using (attributeid) where attributename = 'Topographic Setting';", new FetchCallback() {
    onFetch(pictures) {
      populatePictureGallery("oldBone/topAndStratSetting/topographicSetting", pictures);
    }
  });
  fetchAll("select vocabid, vocabname, pictureurl from vocabulary left join attributekey using (attributeid) where attributename = 'Sediment Type';", new FetchCallback() {
    onFetch(pictures) {
      populatePictureGallery("oldBone/topAndStratSetting/sedimentType", pictures);
    }
  });
  fetchAll("select vocabid, vocabname, pictureurl from vocabulary left join attributekey using (attributeid) where attributename = 'Vulnerability To Erosion';", new FetchCallback() {
    onFetch(pictures) {
      populatePictureGallery("oldBone/topAndStratSetting/vulnerabilityToErosion", pictures);
    }
  });
  fetchAll("select vocabid, vocabname, pictureurl from vocabulary left join attributekey using (attributeid) where attributename = 'Palaeotopographic Setting';", new FetchCallback() {
    onFetch(pictures) {
      populatePictureGallery("oldBone/topAndStratSetting/paleotopographicSetting", pictures);
    }
  });
}

/** Displays or hides the associated materials tabgroup depending on what cluster is selected. **/
toggleAssociatedMaterials() {
  String boneAndOther = null;
  fetchOne("select vocabid from vocabulary join attributekey using (attributeid) where attributename = 'Cluster' and vocabname = '{boneOnly}';", new FetchCallback() {
    onFetch(result) {
      if (!isNull(result)) {
        boneOnly = result.get(0);
        if (boneOnly.equals(getFieldValue("oldBone/basicIdentification/cluster"))) {
          Log.d("showAssociatedMaterials()", "Hiding associated materials Tab");
          cancelTab("oldBone/associatedMaterials", false);
          toggleClusterType(true);        
        } else {
          Log.d("showAssociatedMaterials()", "Showing associated materials Tab");
          showTab("oldBone/associatedMaterials");
          showTab("oldBone/basicIdentification");
          toggleClusterType(false);
        }
      }
    }
  });
}

/** Hides the irrelevant cluster types depending on the cluster chosen. **/
toggleClusterType(Boolean boneOnly) {
  List exclusions = new ArrayList();
  if (boneOnly) {
    exclusions.add("{inistAndOth}");
    exclusions.add("{surfAndOth}");
    exclusions.add("{bothAndOth}");
  } else {
    exclusions.add("{insitBO}");
    exclusions.add("{surfBO}");
    exclusions.add("{insitAndSurf}");
  }
  makeVocab("RadioGroup", "oldBone/basicIdentification/clusterType", "Cluster Type", exclusions);
}

onEvent("oldBone/basicIdentification/cluster", "click", "toggleAssociatedMaterials();");

onEvent("oldBone/associatedMaterials/addInsituMaterial", "click", "recordAssocMaterial(true);");
onEvent("oldBone/associatedMaterials/addSurfaceMaterial", "click", "recordAssocMaterial(false);");

List associatedInsituMaterialVocab = new ArrayList();
List associatedSurfaceMaterialVocab = new ArrayList();

/** Records the selected associated material(s). **/
recordAssocMaterial(Boolean insituMaterial) {
  selectedAssocMaterial = getFieldValue("oldBone/associatedMaterials/associatedInsituMaterial");
  if (!insituMaterial) {
    selectedAssocMaterial = getFieldValue("oldBone/associatedMaterials/associatedSurfaceMaterial");
  }
  print("Selected Material: " + selectedAssocMaterial);
  
  if (selectedAssocMaterial == null || selectedAssocMaterial.isEmpty()) {
    Log.d("recordAssocMaterial()", "Error: no material type selected");
  } else {    
    // determine which assoc material was selected
    for (item : selectedAssocMaterial) {
      value = item.getValue();
      name = item.getName();
      print("value:" + value);
      print("name:" + name);
      
      if (insituMaterial) {
        removeAllViewsAndContainers("associatedMaterials");
        showTabGroup("associatedMaterials");
        for (type : associatedInsituMaterialVocab) {
          if (name.equals(type.get(0))) {
            executeViewTask(new ViewTask() {
              doTask() {
                if (type.get(1).equals("mussel")) {
                  Log.d("recordAssocMaterial()", "insitu mussel selected");
                  cancelTabGroup("associatedMaterials", false);
                  showTab("oldBone/associatedMaterials");
                } else if(type.get(1).equals("hs")) {
                  Log.d("recordAssocMaterial()", "insitu hs selected");
                  makeDynamicVocab("CheckBoxGroup", "associatedMaterials/recordMaterial/associatedHearthMaterial", "Associated Hearth Material", "{associatedHearthMaterial}");
                } else if(type.get(1).equals("eggshell")) {
                  Log.d("recordAssocMaterial()", "insitu eggshell selected");
                  makeDynamicVocab("CheckBoxGroup", "associatedMaterials/recordMaterial/associatedEggshell", "Associated Eggshell", "{associatedEggshell}");
                } else if(type.get(1).equals("artefacts")) {
                  Log.d("recordAssocMaterial()", "insitu artefacts selected");
                  String callback = "onEvent(\"associatedMaterials/recordMaterial/associatedStoneArtefacts\", \"click\", \"updateDynamicAssociatedStone();\");";
                  makeDynamicVocab("CheckBoxGroup", "associatedMaterials/recordMaterial/associatedStoneArtefacts", "Associated Stone Artefacts", "{associatedStoneArtefacts}", callback);
                  makeDynamicVocab("CheckBoxGroup", "associatedMaterials/recordMaterial/rawMaterialTypesPresent", "Raw Material Types Present", "{rawMaterialTypesPresent}");
                } else if(type.get(1).equals("otherwork")) {
                  Log.d("recordAssocMaterial()", "insitu otherwork selected");
                  makeDynamicVocab("CheckBoxGroup", "associatedMaterials/recordMaterial/associatedOtherWorked", "Associated Other Worked Material", "{associatedOtherWorked}");
                } else {
                  Log.d("recordAssocMaterial()", "Error: no matched insitu selected");
                }
              }
            });
          }
        }
      } else {
        removeAllViewsAndContainers("associatedMaterials");
        for (type : associatedSurfaceMaterialVocab) {
          if (name.equals(type.get(0))) {
            if (type.get(1).equals("mussel")) {
              Log.d("recordAssocMaterial()", "surface mussel selected");

            } else if(type.get(1).equals("hs")) {
              Log.d("recordAssocMaterial()", "surface hs selected");

            } else if(type.get(1).equals("eggshell")) {
              Log.d("recordAssocMaterial()", "surface eggshell selected");

            } else if(type.get(1).equals("artefacts")) {
              Log.d("recordAssocMaterial()", "surface artefacts selected");

            } else if(type.get(1).equals("otherwork")) {
              Log.d("recordAssocMaterial()", "surface otherwork selected");

            } else {
              Log.d("recordAssocMaterial()", "Error: no matched surface selected");
            }
          }
        }
      }
      
    }
  }
}

List associatedStoneArtefactsVocab = new ArrayList();

/** Detect and display the relevent associated stone artefact views. **/
updateDynamicAssociatedStone() {
  assocStones = getFieldValue("associatedMaterials/recordMaterial/associatedStoneArtefacts");
  // compare each selected artefact against the stone artefact vocab to determine which one(s) the user selected
  for (item : assocStones) {
    print("stone item selected: " + item);
    for (type : associatedStoneArtefactsVocab) {
      if (item.getName().equals(type.get(0))) {
        executeViewTask(new ViewTask() {
          doTask() {
            if (type.get(1).equals("cs")) {
              Log.d("updateDynamicAssociatedStone", "cs selected");
            } else if (type.get(1).equals("um")) {
              Log.d("updateDynamicAssociatedStone", "um selected");
            } else if (type.get(1).equals("ground")) {
              Log.d("updateDynamicAssociatedStone", "ground selected");
            } else {
              Log.d("updateDynamicAssociatedStone", "Error: no stone artefact selected");
            }
          }
        });
      }
    }    
  }
}
/** Displays or hides the associated materials tabgroup depending on what cluster is selected. **/
toggleAssociatedMaterials() {
  String boneAndOther = null;
  fetchOne("select vocabid from vocabulary join attributekey using (attributeid) where attributename = 'Cluster' and vocabname = '{boneOnly}';", new FetchCallback() {
    onFetch(result) {
      if (!isNull(result)) {
        boneOnly = result.get(0);
        if (boneOnly.equals(getFieldValue("oldBone/basicIdentification/cluster"))) {
          Log.d("showAssociatedMaterials()", "Hiding associated materials Tab");
          cancelTab("oldBone/associatedMaterials", false);
          toggleClusterType(true);        
        } else {
          Log.d("showAssociatedMaterials()", "Showing associated materials Tab");
          showTab("oldBone/associatedMaterials");
          showTab("oldBone/basicIdentification");
          toggleClusterType(false);
        }
      }
    }
  });
}


/** Module Initialisation **/
init() {
  // old bone init
  populateOldBoneAttributes();
  fetchOne("select vocabid from vocabulary join attributekey using (attributeid) where attributename = 'Cluster' and vocabname = '{boneOnly}';", new FetchCallback() {
    onFetch(result) {
      setFieldValue("oldBone/basicIdentification/cluster", result.get(0)); // set the cluster field to be 'Bone Only'
      toggleAssociatedMaterials();
    }
  });
  onEvent("oldBone", "load", "cancelTab(\"oldBone/associatedMaterials\", false);");

  // set the vocab globals
  fetchAll("select vocabid, vocabname from vocabulary left join attributekey using (attributeid) where attributename = 'Associated in situ material';", new FetchCallback() {
    onFetch(result) {
      for (item : result) {
        List temp = new ArrayList();
        temp.add(item.get(0));
        temp.add(item.get(1));
        associatedInsituMaterialVocab.add(temp);
      }
    }
  }); 
  fetchAll("select vocabid, vocabname from vocabulary left join attributekey using (attributeid) where attributename = 'Associated surface material';", new FetchCallback() {
    onFetch(result) {
      for (item : result) {
        List temp = new ArrayList();
        temp.add(item.get(0));
        temp.add(item.get(1));
        associatedSurfaceMaterialVocab.add(temp);
      }
    }
  }); 
  fetchAll("select vocabid, vocabname from vocabulary left join attributekey using (attributeid) where attributename = 'Associated Stone Artefacts';", new FetchCallback() {
    onFetch(result) {
      for (item : result) {
        List temp = new ArrayList();
        temp.add(item.get(0));
        temp.add(item.get(1));
        associatedStoneArtefactsVocab.add(temp);
      }
    }
  }); 
  
  print("associatedInsituMaterialVocab: " + associatedInsituMaterialVocab);
  print("associatedSurfaceMaterialVocab: " + associatedSurfaceMaterialVocab);
}

init();